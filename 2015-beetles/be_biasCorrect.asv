% computes the difference in the yearly mean of maximum summertime
% temperatures between NARCCAP models and NARR reanalysis.

season = 'all';
basePeriod = 'past';
testPeriod = 'past';

baseDataset = 'ncep';
testDataset = 'narr';

baseModels = {''};
testModels = {''};
% baseModels = {'ccsm4', 'cesm1-bgc', ...
%           'gfdl-cm3', 'mpi-esm-mr', ...
%           'gfdl-esm2m', 'gfdl-esm2g', ...
%           'canesm2', 'noresm1-m', ...
%           'hadgem2-es', 'cesm1-cam5', ...
%           'cmcc-cm', 'cmcc-cms', ...    
%           'cnrm-cm5', 'ipsl-cm5a-mr', ...
%           'bnu-esm', 'miroc-esm', ...
%           'mri-cgcm3'};

baseVar = 'tmin';
testVar = 'tasmin';

percentiles = 10:10:100;

baseRegrid = true;

basePeriodYears = 1985:2004;

latBounds = [23 50];
lonBounds = [-128 -63];

baseDir = 'e:/data/';
yearStep = 1;

baseDataDir = '';
baseDatasetStr = '';
if strcmp(baseDataset, 'cmip5')
    if length(baseModels) == 1
        baseDatasetStr = ['cmip5-' baseModels{1}]
    else
        baseDatasetStr = ['cmip5-mm'];
    end
    
    baseDataDir = 'cmip5/output';
    baseEnsemble = 'r1i1p1/';
elseif strcmp(baseDataset, 'ncep')
    baseDatasetStr = ['ncep'];
    baseDataDir = 'ncep-reanalysis/output';
    baseEnsemble = '';
    baseRcp = '';
elseif strcmp(baseDataset, 'narr')
    baseDatasetStr = ['narr'];
    baseDataDir = 'narr/output';
    baseEnsemble = '';
    baseRcp = '';
end

testDataDir = '';
testDatasetStr = '';
if strcmp(testDataset, 'cmip5')
    if length(testModels) == 1
        testDatasetStr = ['cmip5-' testModels{1}]
    else
        testDatasetStr = ['cmip5-mm'];
    end
    
    testDataDir = 'cmip5/output';
    testEnsemble = 'r1i1p1/';
elseif strcmp(testDataset, 'ncep')
    testDatasetStr = ['ncep'];
    testDataDir = 'ncep-reanalysis/output';
    testEnsemble = '';
    testRcp = '';
elseif strcmp(testDataset, 'narr')
    testDatasetStr = ['narr'];
    testDataDir = 'narr/output';
    testEnsemble = '';
    testRcp = '';
end

baseData = {};
baseLat = [];
baseLon = [];

% first load base dataset
['loading base dataset: ' baseDataset]
for y = basePeriod(1):yearStep:basePeriod(end)
    ['year ' num2str(y) '...']
    
    baseDaily = loadDailyData(['e:/data/' baseDataDir '/' baseVar], 'yearStart', y, 'yearEnd', (y+yearStep)-1);
    baseDaily{3} = baseDaily{3}-273.15;
    
    [latIndex, lonIndex] = latLonIndexRange(baseDaily, latBounds, lonBounds);
    baseDaily = {baseDaily{1}(latIndex, lonIndex), baseDaily{2}(latIndex, lonIndex), baseDaily{3}(latIndex, lonIndex, :, :, :)};
    
    if length(baseLat) == 0
        baseLat = baseDaily{1};
        baseLon = baseDaily{2};
    end
    
    baseDaily{3} = reshape(baseDaily{3}, [size(baseDaily{3}, 1), size(baseDaily{3}, 2), size(baseDaily{3}, 3)*size(baseDaily{3}, 4)*size(baseDaily{3}, 5)]);

    baseData = {baseData{:} baseDaily{3}};
    clear baseDaily;
end

baseDist = {};
baseMeans = [];

for xlat = 1:size(baseData{1}, 1)
    if size(baseDist, 1) < xlat
        baseDist{xlat} = {};
    end
    
    for ylon = 1:size(baseData{1}, 2)
        baseDist{xlat}{ylon} = [];
        for n = 1:length(baseData)
            baseDist{xlat}{ylon} = [baseDist{xlat}{ylon}(:); squeeze(baseData{n}(xlat, ylon, :))];
        end
        pIndex = 1;
        cutoffs = [];
        for p = percentiles
            % store cuttoffs so we take mean between each percentile
            cutoffs(pIndex) = prctile(baseDist{xlat}{ylon}, p);
            if pIndex == 1
                baseMeans(xlat, ylon, pIndex) = nanmean(baseDist{xlat}{ylon}(baseDist{xlat}{ylon}(:) < cutoffs(pIndex)));
            else
                baseMeans(xlat, ylon, pIndex) = nanmean(baseDist{xlat}{ylon}(baseDist{xlat}{ylon}(:) < cutoffs(pIndex) & baseDist{xlat}{ylon}(:) > cutoffs(pIndex-1)));
            end
            pIndex = pIndex+1;
        end
    end
end

clear baseDist baseData;

testBiasCorrection = {};
    
for m = 1:length(testModels)
    if strcmp(testModels{m}, '')
        curModel = testModels{m};
    else
        curModel = [testModels{m} '/'];
    end

    testData = {};
    testBiasCorrection{m} = {testModels{m}, []};
    
    ['loading ' curModel ' base']
    for y = basePeriod(1):yearStep:basePeriod(end)
        ['year ' num2str(y) '...']
        
        testDaily = loadDailyData([baseDir baseDataDir '/' curModel ensemble baseRcp testVar '/regrid'], 'yearStart', y, 'yearEnd', (y+yearStep)-1);
        testDaily{3} = testDaily{3}-273.15;
        
        [latIndex, lonIndex] = latLonIndexRange(testDaily, latBounds, lonBounds);
        testDaily = {testDaily{1}(latIndex, lonIndex), testDaily{2}(latIndex, lonIndex), testDaily{3}(latIndex, lonIndex, :, :, :)};
    
        if size(testDaily{3}, 1) ~= size(baseLat, 1) | size(
        
        testDaily{3} = reshape(testDaily{3}, [size(testDaily{3}, 1), size(testDaily{3}, 2), size(testDaily{3}, 3)*size(testDaily{3}, 4)*size(testDaily{3}, 5)]);
        testData = {testData{:} testDaily{3}};
        clear baseDaily;
    end
    
    testDist = {};

    for xlat = 1:size(testData{1}, 1)
        if size(testDist, 1) < xlat
            testDist{xlat} = {};
        end

        for ylon = 1:size(testData{1}, 2)
            testDist{xlat}{ylon} = [];
            for n = 1:length(testData)
                testDist{xlat}{ylon} = [testDist{xlat}{ylon}(:); squeeze(testData{n}(xlat, ylon, :))];
            end
            pIndex = 1;
            cutoffs = [];
            for p = percentiles
                % store cuttoffs so we take mean between each percentile
                cutoffs(pIndex) = prctile(testDist{xlat}{ylon}, p);
                if pIndex == 1
                    curMean = nanmean(testDist{xlat}{ylon}(testDist{xlat}{ylon}(:) < cutoffs(pIndex)));
                else
                    curMean = nanmean(testDist{xlat}{ylon}(testDist{xlat}{ylon}(:) < cutoffs(pIndex) & testDist{xlat}{ylon}(:) > cutoffs(pIndex-1)));
                end
                testBiasCorrection{m}{2}(xlat, ylon, pIndex) = curMean - baseMeans(xlat, ylon, pIndex);
                pIndex = pIndex+1;
            end
        end
    end
    clear testDist testData;
end

save testBiasCorrection;



